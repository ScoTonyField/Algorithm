# 排序

### 1-常用排序算法

| 排序算法         | 时间复杂度 | 是否基于比较 |
| ---------------- | ---------- | ------------ |
| 冒泡、插入、选择 | O(n^2)     | 是           |
| 快排、归并       | O(nlogn)   | 是           |
| 桶、计数、基数   | O(n)       | 否           |

### 2-排序算法的分析

- **最好情况、最坏情况、平均情况时间复杂度**

  为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。**有序度不同的数据，对于排序的执行时间肯定是有影响的**，我们要知道排序算法在不同数据下的性能表现。

- **时间复杂度的系数、常数、低阶**

  时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来

- **比较次数与移动次数**

  基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去

- **排序算法的内存消耗**

  算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法
  
- **排序算法的稳定性**

  稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

  我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。

  这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。为什么要考察排序算法的稳定性呢？

  很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。

  比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。

  最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。

  借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。

  **稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。**第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。

#### 3-跳转链接

- :spades:[冒泡、插入、选择](https://github.com/ScoTonyField/Algorithm/blob/master/DataStructure%26Algorithms/递归/冒泡-插入-选择.md)

- [:hearts:快排、归并](https://github.com/ScoTonyField/Algorithm/blob/master/DataStructure%26Algorithms/递归/快排-归并.md)
- [:clubs:线性排序](https://github.com/ScoTonyField/Algorithm/blob/master/DataStructure%26Algorithms/递归/线性排序.md)

